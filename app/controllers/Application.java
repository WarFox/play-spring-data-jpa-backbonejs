package controllers;

import models.Person;
import models.PersonRepository;
import play.libs.F;
import play.mvc.*;

import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import java.util.concurrent.Callable;

import static play.libs.Akka.future;

/**
 * The main set of web services.
 */
@Named
@Singleton
public class Application extends Controller {

    private final PersonRepository personRepository;

    // We are using constructor injection to receive a repository to support our desire for immutability.
    @Inject
    public Application(final PersonRepository personRepository) {
        this.personRepository = personRepository;
    }

    public Result index() {
        // Perform a future operation that will promise to deliver a person back asynchronously.
        final F.Promise<Person> pp = future(new Callable<Person>() {
            @Override
            public Person call() {
                // For fun we save a new person and then find that one we've just saved. The id is auto generated by
                // the db so we know that we're round-tripping to the db and back in order to demonstrate something
                // interesting. Spring Data takes care of transactional concerns and the following code is all
                // executed on the same thread (a requirement of the JPA entity manager).

                final Person person = new Person();
                person.firstname = "Bruce";
                person.surname = "Smith";
                final Person savedPerson = personRepository.save(person);

                return personRepository.findOne(savedPerson.id);
            }
        });

        // Asynchronously deliver the index page with a message showing the id that was generated.
        return async(pp.map(new F.Function<Person, Result>() {
            @Override
            public Result apply(final Person person) {
                return ok(views.html.index.render("Found id: " + person.id + " of person/people"));
            }
        }));
    }
}
